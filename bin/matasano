#!/usr/bin/env python
# encoding: utf-8

__author__ = "aldur"

"""The main file."""

import matasano.util
import matasano.stats
import matasano.blocks
import matasano.oracle
import matasano.attacker
import matasano.prng

import base64
import argparse

_num2words = {
    1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',
    6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten',
    11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen',
    15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen',
    19: 'nineteen', 20: 'twenty', 30: 'thirty', 40: 'forty',
    50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty',
    90: 'ninety', 0: 'zero'
}


def _number_to_words(n: int) -> str:
    """
    Given a number, convert it to respective words.

    :param n: Number to be converted. Must be 0 <= n < 100
    :return: The number convert to its word representation.
    """
    assert 0 <= n < 100
    try:
        return _num2words[n]
    except KeyError:
        try:
            return _num2words[n - n % 10] + _num2words[n % 10]
        except KeyError:
            raise Exception('Number out of range')


def one():
    """http://cryptopals.com/sets/1/challenges/1/"""
    hex_input = "49276d206b696c6c696e6720796f7" \
                "57220627261696e206c696b652061" \
                "20706f69736f6e6f7573206d75736" \
                "8726f6f6d"
    print("HEX: {}".format(hex_input))

    hex_input = bytearray.fromhex(hex_input)
    b64_output = matasano.util.hex_to_b64(hex_input)
    print("B64: {}".format(b64_output))


def two():
    """http://cryptopals.com/sets/1/challenges/2/"""
    a = bytearray.fromhex("1c0111001f010100061a024b53535009181c")
    b = bytearray.fromhex("686974207468652062756c6c277320657965")
    c = bytearray(matasano.util.xor(a, b))
    print("'{}' xor '{}' = '{}'".format(
        a.decode("ascii"), b.decode("ascii"), c.decode("ascii")
    ))


def three():
    """http://cryptopals.com/sets/1/challenges/3/"""
    s = bytearray.fromhex(
        "1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736"
    )
    key = matasano.stats.most_likely_xor_chars(s)[0]
    plaintext = matasano.util.xor_char(s, key).decode("ascii")
    print("Key: {}, Plaintext: {}".format(key, plaintext))


def four():
    """http://cryptopals.com/sets/1/challenges/4/"""
    input_path = "input/4.txt"
    with open(input_path) as f:
        plaintexts = []
        for line in f:
            b = bytes.fromhex(line.rstrip())
            try:
                c = matasano.stats.most_likely_xor_chars(b)[0]
                plaintext = matasano.util.xor_char(b, c).decode("ascii")
                plaintexts.append(plaintext)
            except UnicodeDecodeError:
                pass

        print("Plaintext found: {}".format(
            min(
                plaintexts,
                key=lambda p: matasano.stats.chi_squared(p)
            )
        ))


def five():
    """http://cryptopals.com/sets/1/challenges/5/"""
    lines = """Burning 'em, if you ain't quick and nimble
I go crazy when I hear a cymbal""".encode("ascii")
    key = "ICE".encode("ascii")
    import binascii
    print("Result: {}".format(
        binascii.hexlify(
            matasano.util.repeating_xor(lines, key)
        )
    ))


def six():
    """http://cryptopals.com/sets/1/challenges/6/"""
    with open("input/6.txt", 'r') as f:
        s = ''.join(l.rstrip() for l in f.readlines())
        b = base64.b64decode(s)

        k_len = matasano.stats.most_likely_key_length(b)
        blocks = matasano.blocks.split_blocks(b, k_len)

        key = tuple(
            map(
                lambda x: matasano.stats.most_likely_xor_chars(x)[0],
                blocks
            )
        )

        print(
            "Key found: \"{}\"".format(''.join(key)),
        )
        print(
            "Plaintext:\n{}".format(
                matasano.util.repeating_xor(
                    b, bytes(ord(c) for c in key)
                ).decode("ascii")
            ),
        )


def seven():
    """http://cryptopals.com/sets/1/challenges/7/"""
    with open("input/7.txt") as f:
        key = b"YELLOW SUBMARINE"
        s = base64.b64decode(f.read())
        print("Decrypted:\n{}".format(
            matasano.blocks.aes_ecb(key, s, decrypt=True).decode("ascii")
        ))


def eight():
    """http://cryptopals.com/sets/1/challenges/8/"""
    with open("input/8.txt", "rb") as f:
        for line in f:
            if matasano.blocks.any_equal_block(line):
                print("Likely to be ECB:\n{}".format(line.decode("ascii")))


def nine():
    """http://cryptopals.com/sets/2/challenges/9/"""
    b = "YELLOW SUBMARINE".encode("ascii")
    size = 20
    print("PKCS padding: {}".format(matasano.blocks.pkcs(b, size)))


def ten():
    """http://cryptopals.com/sets/2/challenges/10/"""
    with open("input/10.txt", "rb") as f:
        b = base64.b64decode(f.read())
        key = "YELLOW SUBMARINE".encode("ascii")
        print(
            "Decrypted:\n{}".format(
                matasano.blocks.aes_cbc(key, b, decrypt=True)[0].decode("ascii")
            )
        )


def eleven():
    """http://cryptopals.com/sets/2/challenges/11/"""
    oracle = matasano.oracle.OracleAesEcbCbc()

    """
    Pass to the oracle something that,
    even after the random adding,
    is smaller than 4 blocks and is all 0s.
    In this way we'll have the two middle blocks
    always full of 0s. ECB is stateless, so they
    will be equal.
    If they're not, then it's CBC.
    """
    b = b"\x00" * ((16 * 4) - 10)
    o = oracle.challenge(b)

    ecb = matasano.blocks.any_equal_block(o)
    print(
        "Guess - Oracle used: {}.".format(
            "ECB" if ecb else "CBC"
        )
    )
    print(
        "Guess is {}.".format(
            "correct" if oracle.guess(ecb) else "wrong"
        )
    )


def twelve():
    """http://cryptopals.com/sets/2/challenges/12/"""
    oracle = matasano.oracle.OracleByteAtATimeEcb()
    attacker = matasano.attacker.AttackerByteAtATimeEcb(oracle)
    attack = attacker.attack()
    print("Guessed hidden string is:\n{}".format(
        attacker.unhidden_string.decode("ascii")
    ))
    print("The attack results was: {}.".format(
        "success" if attack else "failure"
    ))


def thirteen():
    """http://cryptopals.com/sets/2/challenges/13/"""
    oracle = matasano.oracle.OracleProfileForUser()
    attacker = matasano.attacker.AttackerProfileForUser(oracle)
    attacker.get_base_user_profile()
    attacker.get_role_block()
    print("The attack result was: {}.".format(
        "success" if attacker.attack() else "failure"
    ))


def fourteen():
    """http://cryptopals.com/sets/2/challenges/14/"""
    oracle = matasano.oracle.OracleHarderByteAtATimeEcb()
    attacker = matasano.attacker.AttackerHarderByteAtATimeEcb(oracle)
    attacker.discover_block_size()
    print("Prefix len: {}.".format(
        attacker.discover_fixed_string_len())
    )

    attack = attacker.attack()

    print("Guessed hidden string is:\n{}".format(
        attacker.unhidden_string.decode("ascii")
    ))
    print("The attack results was: {}.".format(
        "success" if attack else "failure"
    ))


def fifteen():
    """http://cryptopals.com/sets/2/challenges/15/"""
    pads = (
        b"ICE ICE BABY\x04\x04\x04\x04",
        b"ICE ICE BABY\x05\x05\x05\x05",
        b"ICE ICE BABY\x01\x02\x03\x04"
    )

    for padded in pads:
        try:
            matasano.blocks.un_pkcs(padded, 16)
            print("Padded buffer {} is valid.".format(padded))
        except matasano.blocks.BadPaddingException:
            print("Padded buffer {} is invalid.".format(padded))


def sixteen():
    """http://cryptopals.com/sets/2/challenges/16/"""
    oracle = matasano.oracle.OracleBitflippingCBC()
    attacker = matasano.attacker.AttackerBitFlippingCBC(oracle)

    attack = attacker.attack()
    print("The attack results was: {}.".format(
        "success" if attack else "failure"
    ))


def seventeen():
    """http://cryptopals.com/sets/3/challenges/17/"""
    oracle = matasano.oracle.OracleCBCPadding("input/17.txt")
    attacker = matasano.attacker.AttackerCBCPadding(oracle)

    attack = attacker.attack()
    print("Guessed hidden string is:\n{}".format(
        attacker.discovered_string.decode("ascii")
    ))
    print("Decoding it produces:\n{}".format(
        base64.b64decode(attacker.discovered_string).decode("ascii")
    ))
    print("The attack results was: {}.".format(
        "success" if attack else "failure"
    ))


def eighteen():
    """http://cryptopals.com/sets/3/challenges/18/"""
    key = "YELLOW SUBMARINE".encode("ascii")
    b = base64.b64decode(
        """
        L77na/nrFsKvynd6HzOoG7GHTLXsTVu9qvY/
        2syLXzhPweyyMTJULu/6/kXX0KSvoOLSFQ==
        """
    )
    print("The decryption produced: \n{}.".format(
        matasano.blocks.aes_ctr(
            key, b
        )
    ))


def _fixed_nonce_ctr(oracle: matasano.oracle.OracleFixedNonceCTR):
    attacker = matasano.attacker.AttackerFixedNonceCTR(oracle)

    attack = attacker.attack()
    print("Discovered strings:\n{}".format(
        "\n".join(b.decode("ascii") for b in attacker.discovered_strings)
    ))
    print("The attack results was: {}.".format(
        "success" if attack else "failure"
    ))


def nineteen():
    """http://cryptopals.com/sets/3/challenges/19/"""
    oracle = matasano.oracle.OracleFixedNonceCTR("input/19.txt")
    _fixed_nonce_ctr(oracle)


def twenty():
    """http://cryptopals.com/sets/3/challenges/20/"""
    oracle = matasano.oracle.OracleFixedNonceCTR("input/20.txt")
    _fixed_nonce_ctr(oracle)


def twentyone():
    """http://cryptopals.com/sets/3/challenges/21/"""
    mt_prng = matasano.prng.MT19937(42)
    print("Randomly generated numbers: {}".format(
        [mt_prng.extract_number() for _ in range(10)]
    ))


def _create_parser() -> argparse.ArgumentParser:
    """
    Create the command line argument parser.

    :return: The command line argument parser for this module.
    """
    parser = argparse.ArgumentParser(
        description='Matasano Crypto-Challenge solver.'
    )

    parser.add_argument(
        'problem_number',
        metavar='problem_number',
        type=int,
        help='the number of the problem to be solved'
    )

    return parser


if __name__ == '__main__':
    command_line_parser = _create_parser()
    args = vars(command_line_parser.parse_args())

    problem_number = args['problem_number']
    assert 1 <= problem_number <= 56

    problem = locals().get(_number_to_words(problem_number), None)
    assert problem is not None, \
        "Sorry, not yet implemented."

    assert callable(problem)
    problem()
